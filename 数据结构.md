## 1.链表

### 1.单链表
单链表的建立和输出、删除、插入。建立包含5个结点的单链表，5个结点的值分别是101，89；102、77；105、92；107，68；109，91。
（见《C语言程序设计》P254）

	#include <stdio.h>
	#include <stdlib.h>
	
	struct node
	{
		int num,score;
		struct node *link;
	};
	
	
	
	void main()
	{ 
		struct node *creat(int n);
		void print(struct node *h);
		struct node *find(struct node *h,int x);
		struct node *dele(struct node *h,int x);
		struct node *add(struct node *h);
	
		struct node *head=0,*newhead=0,*newhead2=0;
		head=creat(5);//创建链表
		print(head);//输出链表
		printf("\n");
	
		find(head,105);//查找学号为105的链表结点，输出该结点数据域
		printf("\n");
	
		newhead=dele(head,107);//删除学号为107的链表结点
		print(newhead);//输出删除后的新链表
		printf("\n");
		print(head);
		printf("\n");
	
		newhead2=add(newhead);//插入新结点
		print(newhead2);//输出插入新结点后的链表
		printf("\n");
	
		while(1)
		{
			;
		}
	}
	
	struct node *creat(int n)//链表创建函数，参数n为节点个数，函数返回表头指针
	{
		struct node *h=0,*p,*q;
		int i;
		for(i=1;i<=n;i++)
		{
			q=(struct node *)malloc(sizeof(struct node));
			scanf("%d%d",&q->num,&q->score);
			q->link=0;//为新结点指针域赋值为0,故最后效果即最后一个结点指针域为0
	
			if(h==0)//第一次进入for循环，把链头地址q用h保存
			{
				h=q;
			}
			else
			{
				p->link=q;
	
			}
			p=q;//p依次指向新的链表节点
		}
		return h;
	}
	
	void print(struct node *h)//输出链表函数
	{
		while(h)
		{
			printf("num=%d\tscore=%d\n",h->num,h->score);
			h=h->link;
		}
	}
	
	struct node *find(struct node *h,int x)//查找链表函数
	{
		struct node *p;
		p=h;
		while(p!=0&&p->num!=x)//由上创建链表的函数create(n)知，最后一个结点的指针域为0。
		{					  //这里条件即为如果当前结点不是最后一个结点指向的节点，且数据域的学号不为我们要找的x
			p=p->link;//p指向下一个结点
		}
		if(p)     //p最后不等于0表示找到了指定学号的学生
		{
			printf("num=%d\tscore=%d\n",p->num,p->score);
		}
		else
		{
			printf("查无此学生\n");
		}
	}
	
	struct node *dele(struct node *h,int x)//删除链表结点函数
	{
		struct node *p,*q;
		p=h;
		while(p!=0&&p->num!=x)
		{
			q=p;//最终q是要删除节点的上一个结点的指针
			p=p->link;//最终p是要删除的节点的指针
	
		}
		if(p==0)
		{
			printf("链表中无此结点!\n");
		}
		else if(p==h)
		{
			h=p->link;
		}
		else
		{
			q->link=p->link;
		}
		return h;
	}
	
	struct node *add(struct node *h)//插入新结点，要求插入后新节点的num与旧结点的num们是由小到大的顺序排列
	{
		struct node *q,*p,*t;
		q=(struct node *)malloc(sizeof(struct node));
		printf("输入要插入结点的数据域num,score:\n");
		scanf("%d%d",&(q->num),&(q->score));
		p=h;
		while(p!=0)
		{
			if(p->num<q->num)
			{
				t=p;
				p=p->link;
			}
			else
			{
				break;
			}
		}
		if(p==h)
		{
			q->link=h;
			h=q;
		}
		else
		{
			t->link=q;
			q->link=p;
		}
		return h;
	}


### 2.双链表
创建双链表，并实现其删除、插入结点。
（见《程序员面试宝典》P139)
	#include<stdio.h>
	#include<stdlib.h>
	
	typedef struct student
	{
		int data;
		struct student *next;
		struct student *pre;
	}dnode;
	
	dnode *creat()//创建双链表，以输入0为链表结束标志
	{
		dnode *head,*p,*s;
		int x,cycle=1;
		head=(dnode *)malloc(sizeof(dnode));
		p=head;
		while(cycle)
		{
			printf("请输入链表数据域data：\n");
			scanf("%d",&x);
			if(x!=0)
			{
				s=(dnode *)malloc(sizeof(dnode));
				s->data=x;
				printf("%d\n",s->data);
				p->next=s;
				s->pre=p;
				p=s;
	
			}
			else
			{
				cycle=0;
			}
		}
		head=head->next;
		head->pre=NULL;
		p->next=NULL;
	
		printf("\n yyy %d",head->data);
		return(head);
	}
	
	void print(dnode *h)
	{
		while(h)
		{
			printf("data=%d\n",h->data);
			h=h->next;
		}
	
	}
	
	dnode *del(dnode *h,int num)//双链表删除结点
	{
		dnode *p,*q,*t;
		p=h;
		while(p->next!=NULL&&p->data!=num)
		{
			q=p;
			p=p->next;
		}
		
		if(p->data==num)
		{
			if(p==h)
			{
				h=p->next;
				h->pre=NULL;
				free(p);
			}
			else
			{
				t=p->next;
				q->next=t;
				t->pre=q;
			}
		}
		else
		{
			printf("无此结点!\n");
		}
		return h;
	}
	
	dnode *insert(dnode *h,int n)//双链表插入结点
	{
		dnode *p,*q,*t;
		q=(dnode *)malloc(sizeof(dnode));
		q->data=n;
		p=h;
		while(p->next!=NULL&&(p->data<q->data))
		{
			t=p;
			p=p->next;
		}
	
		if(p==h)//如果插入的这个值最小，插在链表最前端
		{
			h=q;
			h->next=p;
			h->pre=NULL;
		}
		else if(p->data>=q->data)
		{
			t->next=q;
			q->pre=t;
			q->next=p;
			p->pre=q;
		}
		else//p->next==NULL
		{
			p->next=q;
			q->pre=p;
			q->next=NULL;
		}
	
		return h;
	
	}
	
	
	main()
	{
		dnode *head,*head1,*head2,*head3,*head4;
		head=creat();//创建双链表，数据域为2，3，4，5
		print(head);
		printf("\n");
	
		head1=del(head,3);//删除数据域data=3的结点
		print(head1);
		printf("\n");
	
		head2=insert(head1,3);//插入数据域data=3的结点
		print(head2);
		printf("\n");
	
		head3=insert(head2,6);//插入数据域data=6的结点
		print(head3);
		printf("\n");
	
		head4=insert(head2,1);//插入数据域data=1的结点
		print(head4);
		printf("\n");
	
	
	
		while(1)
		{
			;
		}
	
	}

### 3.循环单链表
已知n个人（编号为1，2，3，……n)围坐在一张圆桌周围。从编号为k的人开始报数，从1开始报数，数到m的那个人出列；他的下一个又从1报数，数到m出列。依次重复下去，使所有人全部出列。

	#include<stdio.h>
	#include<stdlib.h>
	
	typedef struct LNode
	{
		int data;
		struct LNode *link;
	}LNode,*LinkList;
	
	void JOSEPHUS(int n,int k,int m)
	{
		LinkList p,r,list,curr,t;//都是指针
		int i,s;
		p=(LinkList)malloc(sizeof(LNode));
		p->data=0;//第一个结点p装载数据域为0
		p->link=p;
		curr=p;
		for(i=1;i<n;i++)//链表的数据域装载的是从0到n-1的数值，循环从1开始装载。
		{
			t=(LinkList)malloc(sizeof(LNode));
			t->data=i;
			t->link=curr->link;
			curr->link=t;
			curr=t;
		}
	
		while(k--)
		{
			r=p;//p本来为序号0的结点，这样循环（k-1）次，最后p指向k-1,k-1就是第k个人。
			p=p->link;
		}
		while(n--)
		{
			for(s=m-1;s>=0;s--)//执行循环m次，最后p指向data=(k-1+m-1)，即报数为m的人
			{
				r=p;//r保存的是指向第k个人（即data=k-1）的人的指针
				p=p->link;
			}
	
			r->link=p->link;//指向第k个人（即data=k-1）的r的link指向报完数的下一个人（即data=k-1+m）
			printf("%d->",p->data);//输出报数为m(即data=k-1+m)的人的data
			free(p);//释放这个报数的人的存储空间
			p=r->link;//p指向报完数的下一个人（即data=k+m)
		}
	
	}
	
	main()
	{
		JOSEPHUS(13,4,1);
	
		while(1)
		{
			;
		}
	}


### 4.队列
编程实现链表队列的入队出队操作

	#include<stdio.h>
	#include<stdlib.h>
	
	typedef struct student
	{
		int data;
		struct student *next;
	}node;
	
	typedef struct linkqueue//队列
	{
		node *first,*rear;
	
	}queue;
	
	queue *insert(queue *HQ,int x)//队列入队（进入队尾）
	{
		node *s;
		s=(node *)malloc(sizeof(node));
		s->data=x;
		s->next=NULL;
	
		if(HQ->rear==NULL)
		{
			HQ->first=s;
			HQ->rear=s;
		}
		else
		{
			HQ->rear->next=s;
			HQ->rear=s;
		}
	
		return HQ;
	}
	
	queue *del(queue *HQ)//队列出队（弹出队头）
	{
		node *p;
		int x;//存储弹出的队头值
		if(HQ->first==NULL)
		{
			printf("溢出\n");
		}
		else
		{
			if(HQ->first==HQ->rear)
			{
				HQ->first=NULL;
				HQ->rear=NULL;
			}
			else
			{
				p=HQ->first;
				x=p->data;
				HQ->first=HQ->first->next;
				free(p);
				printf("弹出队头%d\n",x);
	
			}
			return HQ;
	
		}
	}
	
	main()
	{
		queue *list;
		int i;
		list=(queue *)malloc(sizeof(queue));
		list->first=NULL;
		list->rear=NULL;
	
		for(i=1;i<=5;i++)
		{
			list=insert(list,i);
			printf("现在的队尾是%d\n",list->rear->data);
		}
		printf("\n");
	
		for(i=1;i<=4;i++)
		{
			list=del(list);
			printf("现在的队首是%d\n",list->first->data);
		}
	
		while(1)
		{
			;
		}
	}