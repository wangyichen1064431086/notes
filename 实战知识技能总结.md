# 实战知识技巧总结

## 1.关于框架
- 获取当前窗口的某iframe框架
    
    	```
    	var oneframe=window.frames["iframe的id"];
    	```

- 父页面js操纵子页面元素

	    ```
		var oneframe=window.frames["iframe的id"];
		var oneElement=oneframe.contentDocument.getElementById("子页面某元素的id");
		```
- 子页面js操纵父页面元素

        ```
	    window.parent.document.getElementById("父页面某元素的id");
	    ```

## 2.关于函数声明的位置
在严格模式下，函数声明只能在最顶层（不能写在if等里面），或者在另一个函数中。

## 3.关于页面是刷新还是关闭的判断
onbeforeunload很多浏览器不支持，最好不用。

[用js判断页面是刷新还是关闭](http://www.jb51.net/article/30640.htm)

	该方法貌似不行。。。貌似只有ie可以
	event.clientX始终为null,因为根本就不会获得它啊，
	event.clientX只针对可视区域，而关闭和刷新按钮根本不在浏览器可视区。

[js判断页面是关闭还是刷新](http://blog.csdn.net/yaoyaoopen/article/details/9835193)

	该方法也貌似只有ie或ff可以

***很难找到一个满足Chrome的方法***


## 4.检测一个事件在浏览器中是否存在
- (1) 简易方法

		'onclick' in document.documentElement;
		'onclick' in window;

- (2) 靠谱方法

		function detectEventSupport(eventName) {
		    var tempElement = document.createElement('div'),
		        isSupported;
		    eventName = 'on' + eventName;
		    isSupported = (eventName in tempElement); // 使用第一种方式
		    // 如果第一种方式行不通，那就来看看它是不是已知事件类型
		    if(!isSupported) {
		        tempElement.setAttribute(eventName, 'xxx');
		        isSupported = typeof tempElement[eventName] === 'function';
		    }
		    // 清除掉动态创建的元素，以便内存回收
		    tempElement = null;
		    // 返回检测结果
		    return isSupported;
		}

## 5.关于clientX，offsetX,screenX
<http://www.2cto.com/kf/201409/333401.html>
<http://blog.csdn.net/hdchangchang/article/details/8443237>

**可视区域不包括工具栏和滚动条**

## 6.去掉li前的点：
设置ul元素的 

	list-style-type: none;

## 7.为元素添加事件处理程序之前可以在外面添加一个

	EventUtil.addHandler(window,"load",function(){
		Elem.addHandler(```);
		``````
	})

以确保页面以加载完毕，否则操作还没加载的元素可能会出错。