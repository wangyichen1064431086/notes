## 一、todo
### 1.做牛客上的题
### 2.整理牛客上的错题
### 3.看《JavaScript高级程序设计》Chapter5,10，11，12
### 4.整理FF,IE等浏览器的区别
### 7.看《HTML5权威指南》某几张漏掉的：Chapter21,Chapter22
### 8.看w3school上css手册
重点看：CSS参考手册 定位属性
### 9.看网上的笔试贴
### 10.复习数组方法 √
### 11.复习字符串方法
### 12.复习正则，猛刷正则和字符串方法
### 13.复习算法和数据结构


## 二、专题整理



### 1.Dom节点流操作练习

#### 1.以浏览器兼容方式确定一个节点是不是另一个节点后代

参见《JavaScript高级程序设计》P300

	function contains(refNode,otherNode) {
	    if (typeof refNode.contains=="function"&&(!client.engine.webkit||client.engine.webkit>=522)) {
	        return refNode.contains(otherNode);
	    }
	    else if (typeof refNode.compareDocumentPosition=="function") {
	        return !!(refNode.compareDocumentPosition(otherNode)&16);
	    }
	    
	    else{
	        var node=otherNode.parentNode;
	        do{
	            if (node==refNode) {
	                return true;
	            }
	            else{
	                node=node.parentNode;
	            }
	        }
	        while (node!=null);
	        return false;
	    }
	}

### 2.特别容易忘记弄错的偏知识点复习
#### 1.关于基本包装类型和转型函数的区别

	var value="25";
	var num1=Number(value);
	console.log(typeof num1);//number
	
	var num2=new Number(value);
	console.log(typeof num2);//object
	console.log(num2 instanceof Number);//true

#### 2.Boolean类型的基本类型和基本包装类型的区别

	var falseObj=new Boolean(false);
	var rel=falseObj&&true;（1）
	console.log(rel);//true 
	
	var falseValue=false;
	var rel2=falseValue&&true;
	console.log(rel2);//false

上面（1)代码是对falseObj求值而不是对它的值（false)求值。而**布尔表达式中的所有对象都会被转换为true**（见《JavaScript高级程序设计》P27）,故falseObj在此布尔表达式中代表true。

	var numObj=new Number(10);
	var numValue=10;
	console.log(typeof numObj);//object
	console.log(typeof numValue);//number
	console.log(numObj instanceof Object);//true
	console.log(numObj instanceof Number);//true
	console.log(numValue instanceof Object);//false
	console.log(numValue instanceof Number);//false
用typeof测试基本类型值，会返回number;测试Number基本包装类型，会返回object。Number基本包装类型是object类型实例，也是Number类型实例；基本类型则不是它们的实例。

#### 3.需要转义的字符。


### Charpert3笔记
#### 4.使用Number()和parseInt() parseFloat转换区别。
详见《JavaScript高级程序设计》P30
##### 

	Number()可以针对任何类型。
	parseInt（）和parseFloat（）都只针对字符串

##### 1.转换空字符串
	Number("");//0
	parseInt("");//NaN
	
##### 2.转换包含数字的字符串

	console.log(parseInt("1234Blue"));//1234
	console.log(parseInt("Blue1234"));//NaN

	console.log(Number("1234Blue"));//NaN
	console.log(Number("Blue1234"));//NaN

parseInt（）从第一个非空格字符开始解析，直到遇到第一个非字符数字；
parseFloat()从第一个非空格字符开始解析，直到遇到第一个无效的浮点数字字符。（遇到第二个小数点就无效了）

##### 3.parseInt()可指定转换基数

	console.log(parseInt("10",2));
	console.log(parseInt("10",8));
	console.log(parseInt("10",10));

**为避免错误的解析，任何时候都要明确指定基数**

##### 4.parseFloat()不能解析十六进制等其他进制，只能解析十进制

	console.log(parseFloat("0xA"));//0
	console.log(parseInt("0xA"));//10

#### 4.两种涉及转换数据进制的方法。

	var n=10;
	console.log(n.toString(2));//1010
	console.log(parseInt(n,2));//2

- n.toString(2)是返回把**数值**转换为相应进制（2）的**字符串**
- parseInt(n,2)是把**字符串**按照指定进制（2）来解析为**十进制数据**	

#### 5.toString()方法和String()方法的区别

	//console.log(null.toString());报错
	//console.log(undefined.toString());报错
	
	console.log(String(null));//"null"
	console.log(String(undefined));//"undefined"

- null和undefined没有toString()方法，使用会报错。数值、布尔值、对象、字符串有这个方法。
- String()能将任何类型的值转换为字符串，包括null和undefined

#### 6.自增自减操作符用在其他非数值值。

	var s1="2";
	var s2="z";
	var b=false;
	var f=1.1;
	var o={
	    valueOf: function(){
	                 return -1;
	            }
	};
	
	s1++;
	s2++;
	b++;
	f--;
	o--;
	
	console.log(s1);//3
	console.log(s2);//NaN
	console.log(b);//1，若b之前为true则++后为2
	console.log(f);//0.10000000000000009
	console.log(o);//-2

#### 7.一元+操作符和-操作符

	var s1="01";
	var s2="1.1";
	var s3="z";
	var b=false;
	var f=1.1;
	var o={
	    valueOf: function(){
	                 return -1;
	            }
	};
	
	s1=+s1;
	s2=+s2;
	s3=+s3;
	b=+b;
	f=+f;
	o=+o;
	
	console.log(s1);//1
	console.log(s2);//1.1
	console.log(s3);//NaN
	console.log(b);//0
	console.log(f);//1.1
	console.log(o);//-1

一元+操作符作用类似于Number()转型函数


	var s1="01";
	var s2="1.1";
	var s3="z";
	var b=false;
	var f=1.1;
	var o={
	    valueOf: function(){
	                 return -1;
	            }
	};
	
	s1=-s1;
	s2=-s2;
	s3=-s3;
	b=-b;
	f=-f;
	o=-o;
	
	console.log(s1);//-1
	console.log(s2);//-1.1
	console.log(s3);//NaN
	console.log(b);//-0
	console.log(f);//-1.1
	console.log(o);//1

一元键操作符应用于数值时会变成负数。应用于非数值时，和+转换规则类似。

#### 8.两个逻辑非（！）可得到Boolean()方法一样的结果

	console.log(!!"blue");//true
	console.log(Boolean("blue"));//true
	
	console.log(!!0);//false
	console.log(Boolean(0));//false
	
	console.log(!!NaN);//false
	console.log(Boolean(NaN));//false
	
	console.log(!!"");//false
	console.log(Boolean(""));//false
	
	console.log(!!12345);//true
	console.log(Boolean(12345));//true

#### 9.逻辑与（&&）、逻辑或（||）都是短路操作

##### &&:
短路操作。如果第一个操作数是false，则不会再对第二个操作数求值。在有一个操作数不是布尔值的情况下，逻辑与操作不一定返回布尔值。规则如下：

- 若第一个操作数是对象，返回第二个操作数
- 若第二个操作数是对象，则只有在第一个操作数的求值结果为true才返回第二个操作数
- 若两个操作数都是对象，则返回第二个操作数
- 若有一个操作数是null,NaN,undefined,则返回null,NaN,undefined


		var found=true;
		var result=(found && someUndefinedValue);//报错,不能在逻辑与中使用未定义的值
		console.log(result);//不会执行
		
		var found=false;
		var result=(found && someUndefinedValue);
		console.log(result);//false

##### ||：
短路操作。如果第一个操作数是ture,则不会再对第二个操作数求值。在有一个操作数不是布尔值的情况下，逻辑或操作不一定返回布尔值。规则如下：

- 若第一个操作数是对象，返回第一个操作数
- 若第一个操作数的求值结果为false,则返回第二个操作数
- 若两个操作数都是对象，则返回第一个操作数
- 若有一个操作数是null,NaN,undefined,则返回null,NaN,undefined

		var found=true;
		var result=(found || someUndefinedValue);
		console.log(result);//true
		
		var found=false;
		var result=(found || someUndefinedValue);//报错
		console.log(result);//不会执行

#### 10.除法与C不同

	console.log(5/3);//1.6666666666666667

js两个整数相除是可以得到小数的。和C除完就是整数不同。

#### 11.加法操作符和减法操作符的区别
如果两个操作数有一个是字符串：

- 加法是将另一个操作数转换为字符串，然后再将两个操作数拼接起来。
- 减法是将在后台调用Number()将这个字符串转换为数值，再执行减法计算。

		console.log("sum is "+1+1); //sum is 11
		console.log("sum is "+(1+1)); //sum is 2
		console.log("1"+1);//11
		console.log("1"+"1");//11

		console.log(5-true);//4
		console.log(NaN-1);//NaN
		console.log("5"-3);//2
		console.log("5"-"3");//2
		console.log(5-"3");//2
		console.log(5-"");//5
		console.log("5"-"abc");//NaN

#### 12.相等全等比较规则

- 如果有一个操作数是布尔值，则在比较之前true转换为1，false转换为0；
- 如果操作数一为字符串，一为数值，则比较前把字符串转换为数值；
- 如果操作数一为对象，一不为对象，则调用对象的valueOf()方法，得到基本类型值再按前面的规则进行比较。
- null和undefined相等；
- 比较前，null和undefined不会转换成其他任何值；
- 有一个操作数是NaN，则相等操作符返回false,不相等操作符返回true。即使两个都是NaN也是不相等；
- 如果两个操作数都是对象，则如果它们指向同一个对象相等操作符返回true，否则返回false。

		console.log(null==undefined);//true
		console.log("NaN"==NaN);//false
		console.log(NaN==5);//flse
		console.log(NaN!=NaN);//true
		console.log(false==0);//true
		console.log(true==1);//true
		console.log(true==2);//false
		console.log(undefined==0);//false
		console.log(null==0);//false
		console.log("12"==12);//true

关于全等：

		console.log("55"===55);//false
		console.log(null===undefined);//false

#### 13.使用复合赋值操作符不会带来任何性能的提升
如num+=10与num=num+10性能一样。

#### 14.label与循环联合使用

	var num=0;
	
	outermost:
	for (var i=0;i<10;i++) {
	    for (var j=0;j<10;j++) {
	        if (i==5&&j==5) {
	            break outermost;
	        }
	        num++;
	    }
	}
	
	console.log(num);//55
添加标签导致break不仅会退出内部循环，还会退出外部循环。

	var num=0;
	
	outermost:
	for (var i=0;i<10;i++) {
	    for (var j=0;j<10;j++) {
	        if (i==5&&j==5) {
	            continue outermost;
	        }
	        num++;
	    }
	}
	
	console.log(num);//95
continue会在i==5&&j==5之后退出内部循环，继续执行外部循环。

#### 15.switch语句的不常用方法

	switch ("hello world") {
	    case "hello "+"world":
	        console.log("Greetint was found.");
	        break;
	    case "goodbye":
	        console.log("Closing was found.");
	        break;
	    default:
	        console.log("Unexpected message.");
	}//"Greetint was found."
switch的case值可以是字符串拼接表达式，它与switch的字符串进行比较得到结果。

	var num=25;
	
	switch (true) {
	    case num<0:
	        console.log("Less than 0.");
	        break;
	    case num>=0&&num<10:
	        console.log("Between 0 and 10.");
	        break;
	    default:
	        console.log("More than 10");
	}//More than 20
给switch传递true,因为每个case都可以返回一个布尔值。这样每个case按照顺序被求值，直到找到匹配的值或遇到default。

#### 16.函数的return
- 函数中return之后的语句**永远也不会**执行
- 一个函数可以包含多个return
- return可以不带任何返回值。这时，函数执行后将返回undefined。

#### 17.关于函数的arguments
##### (0)arguments与数组类似，但并不是Array实例。

##### (1）命名参数只提供便利，但不是必须的。
	
	function doAdd() {
	    if (arguments.length==1) {
	        console.log(arguments[0]);
	    }
	    else if (arguments.length==2) {
	        console.log(arguments[0]+arguments[1]);
	    }
	    else{
	        console.log("lalala");
	    }
	}
	
	doAdd(10);//10
	doAdd(10,20);//30

##### (2)arguments可以和命名参数一起使用。

	function doAdd(num1,num2) {
	    if (arguments.length==1) {
	        console.log(arguments[0]);
	    }
	    else if (arguments.length==2) {
	        console.log(arguments[0]+num2);
	    }
	    else{
	        console.log("lalala");
	    }
	}
	
	doAdd(10);//10
	doAdd(10,20);//30

##### （3）arguments值永远与对应的命名参数的值保存同步。

	function doAdd(num1,num2) {
	   arguments[1]=10;
	   console.log(arguments[1]);
	   console.log(num2);
	}
	
	doAdd(10,10);//10
	             //10   
	doAdd(5,20);//10
	            //10
每次执行函数都会重写第二个参数。修改了arguments[1]，也就修改了num2。
但arguments[1]和num2并不是相同的内存空间，它们的内存空间时独立的，但值会同步。

##### （5）没有传递值的命名参数将自动被赋予undefined值。

#### 18.JS函数没有重载
其他语言中两个函数同名，但签名（接受的参数类型和数量）不同即可成为两个函数。

JS定义了两个相同名字的函数，那该名字就只属于后定义的函数。


### Chapter4笔记
#### 1.关于引用类型值的访问
两种数据类型的值：基本类型值和引用类型值。引用类型的值是保存在内存中的对象，JavaScript不允许直接访问内存中的位置，即**不能直接操作对象的内存空间**。在操作对象时，实际上是**操作对象的引用而非实际的对象**。故引用类型的值是按**引用**访问的。

#### 2.复制基本类型值和引用类型值的不同机制

- 复制基本类型值：重新一个新值，将原值复制到位新变量分配的位置上。两个变量完全独立，新变量只是原值的一个副本，它们参与任何操作互相不影响。

- 复制引用类型值：值的副本实际是一个**指针**，这个指针指向存储在堆中的一个对象。复制结束后，两个变量将引用同一个对象。改变其中一个变量，就会改变另一个。

		var obj1=new Object();
		var obj2=obj1;
		
		obj1.name="Nicholas";
		console.log(obj2.name);//"Nicholas"

#### 3.函数参数的按值传递
访问变量有按值和按引用两种方式，函数参数只能按值传递。

- 传递基本类型值：被传递的值会复制给一个局部变量；
- 传递引用类型值：该值在内存中的地址（指针）会复制给一个局部变量。***难***

	以下例子说明即使引用类型的值是按值传递给参数的，该参数也会按引用访问同一个对象。

		function setName(obj) {
		    obj.name="Nicholas";
		}
		
		var person=new Object();
		setName(person);
		console.log(person.name);//"Nicholas"

	以下例子说明引用类型的值确实是按值传递的。因为如果person按引用传递，那么其就会自动被修改为指向name属性为“Greg”的新对象。但person.name不变，可见即使在函数内部修改了参数的值，原始的引用扔未改变。

	其实，函数内部重写obj时，这个变量引用的就是一个局部变量对象了，岂会在函数执行完后自行销毁。
	
		function setName(obj) {
		    obj.name="Nicholas";
		    obj=new Object();
		    obj.name="Greg";
		}
		
		var person=new Object();
		setName(person);
		console.log(person.name);//"Nicholas"

#### 4.typeof和instanceof检测类型比较
- typeof：检测变量是哪种基本数据类型
- instanceof:检测变量是不是某一种对象。引用类型的值检测Object都是true。基本类型的值检测Object为false,因为基本类型不是对象。
       
		//使用typeof
		var s="Nicholas";
		var b=true;
		var i=22;
		var u;
		var n=null;
		var o=new Object();
		var reg=new RegExp();
		
		console.log(typeof s);//string
		console.log(typeof b);//boolean
		console.log(typeof i);//number
		console.log(typeof u);//undefined
		console.log(typeof n);//object
		console.log(typeof o);//object
		console.log(typeof reg);//object，低版本Chrome和Safari返回function
	   
		//使用instanceof
		var o=new Object();
	
		var arr=new Array();
		var reg=new RegExp();
		var i=22;
		
		console.log(o instanceof Object);//true
		
		console.log(arr instanceof Object);//true
		console.log(arr instanceof Array);//true
		
		console.log(reg instanceof Object);//true
		console.log(reg instanceof RegExp);//true
		
		console.log(i instanceof Object);//false


#### 5.有关执行环境和作用域的几个概念
##### （1）**变量对象：**
-  每个执行环境都有一个对应的变量对象，该环境中定义的所有变量和函数都保存在这个对象中。
-  全局执行环境对应window对象，故所有全局变量和函数都是window对象的属性和方法。
-  某执行环境中的所有代码执行完后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁。全局执行环境直到关闭网页或浏览器才会被销毁。

##### （2）**环境栈**机制
当直流进入一个函数时，函数的环境就会被推入一个环境栈中。函数执行完后，栈将其弹出，控制权又交还给之前的执行环境。

##### （3）**作用域链**
- 其用途是保证执行环境可以有序访问变量和函数。
- 作用域链的前端是当前执行环境的变量对象。下一个变量对象来自包含环境。再下一个变量对象来自下一个保护环境，一直延续到全局执行环境的变量对象。
- 内部环境可以通过作用域链访问所有的外部环境，外部环境不能访问内部环境的任何变量和函数。
- 函数参数也相对于函数局部变量，访问规则同其他局部变量。

eg1:

	var color1="blue";
	
	function changeColor1() {
	    var color2="red";
	    
	    function changeColor2() {
	        var color3=color2;
	        color2=color1;
	        color1=color3;
	        
	        console.log(color1+" "+color2+" "+color3);//red blue red
	        //这里可访问color1、color2、color3
	    }
	    changeColor2();
	    console.log(color1+" "+color2);//blue red
	    //这里可访问color2、color3
	}
	
	console.log(color1);//blue
	//这里只能访问color1
	
	changeColor1();

eg2:

	var color="blue";
	
	function getColor() {
	    var color="red";
	    return color;
	}
	
	console.log(getColor());//red

#### 6.JavaScript没有块级作用域

#### 7.关于var声明
- var声明的变量会被添加到最接近的环境中
- 没有var则被添加到全局环境成为全局变量，不推荐不带var的声明。

#### 8.自动垃圾收集机制
垃圾收集机制原理：找出不再继续使用的变量，然后释放其所占用的内存。垃圾收集器会按照固定的时间间隔周期性执行这一操作。

局部变量只在函数执行的过程中存在，这个过程中会为局部变量在栈（或堆）内存上分配相应的空间，以便存储它们的值。直至函数执行结束，局部变量就没有存在的必要了可以释放它们的内存。垃圾收集器必须跟踪哪个变量有用哪个变量没用。

##### 方式一：标记清除
1. 垃圾收集器在运行的时候给存储在内存中的所有变量都加上标记；
2. 然后，去掉环境中的变量及被环境中的变量引用的标记；
3. 之后再被加上标记的变量就是准备删除的变量；
4. 最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并收回它们所占的内存空间。

##### 方式二：引用计数
引用计数即跟踪每个值被引用的次数。
1. 声明了一个变量并将一个引用类型的值赋给该变量时，该值引用次数就是1；
2. 若该值又被赋给了另外一个值，则该值引用次数加1，为2；
3. 相反，如果包含对这个值引用的变量又取得了另一个值，则这个值引用次数减1；
4. 当值的引用次数变为0时，说明没有办法再访问这个值了，故可将其所占的内存空间收回来；
5. 当垃圾收集器再次运行时，它就会释放那些引用次数为0的值所占用的内存。

**问题：循环引用**

当两个对象互相引用的时候，它们的引用计数永远也不会为0，造成问题。

##### 浏览器采用方式
目前主流浏览器都是**标记清楚**式的垃圾回收策略。只不过时间间隔不同。

IE有一部分对象不是原生JavaScript对象，其BOM和DOM中的对象就是C++编写的COM(组件对象模型），COM的垃圾回收机制是引用计数。**故只要在IE中涉及COM对象就存在循环引用问题。**  不过，**IE把BOM和DOM都换成了真正的JavaScript对象，故避免了该问题。**

#### 9：管理内存：提升性能的方式之一
现实：分配给Web浏览器的可用内存数量通常比分配给桌面应用程序的少。这是出于安全方面的考虑，方式运行JavaScript网页耗尽全部系统内存而导致系统崩溃。

故确保占用最少的内存可以让页面获得更好的性能。**优化内存占用**的最佳方式：为执行中的代码只保存必要的数据。

**优化方法：**

**解除引用：**对全局变量在不需要使用它的时候将它手动设为null。

不过，解除引用并不意味着自动回收该值所占的内存。解除引用的作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。


