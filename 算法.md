# 算法复习
## 排序
### 1.快速排序法

	# include<stdio.h>

	void quickSort(int *list,int i,int j);
	int Partition(int *list,int i,int j);
	
	main(){
		int list[10];
		int k;
		int i=0,j=9;
		printf("请输入10个数：");
		for(k=0;k<10;k++){
			scanf("%d",&list[k]);
		}
		printf("\n");
		quickSort(list,i,j);
		for(k=0;k<10;k++){
			printf("%d\t",list[k]);
		}
		printf("\n");
		while(1)
		{
			;	
		}
	}
	
	void quickSort(int *list,int i,int j){
		int pivotPos=0;//初始基准的位置选为0
		if(i<j){
			pivotPos=Partition(list,i,j);//调用Partition函数后，得到此基准值的位置（保证左边的小于它，右边的大于它）
			quickSort(list,i,pivotPos-1);//对基准值位置的左区间递归调用quickSort函数
			quickSort(list,pivotPos+1,j);//对基准值位置的右区间递归调用quickSort函数
		}
	
	}
	
	int Partition(int *list,int i,int j)
	{
	   
	   int pivot=list[i];//基准值首先设为list[i](i初始为0,故基准值即为list[0])
	   int t;
	   int k;
	  // printf("%d\r%d\n",i,j);
	   while(i<j)
	   {//当i<j时，轮流从右向左、从左向右遍历数组值与基准值比较
		   while(i<j&&list[j]>list[i])
		   {//当i<j时，从j向左扫描（即j--),当list[j]不再大于基准值list[j]时，扫描终止
				j--;
		   }
		   if(i<j)
		   {//扫描终止后，交换list[i]和list[j]的值，交换后list[j]中装的是基准值
		   		t=list[i];
				list[i]=list[j];
				list[j]=t;
		   }
		
	
			while(i<j&&list[i]<list[j])
			{//当i<j时，从i向右扫描（即i++)，当list[i]不再小于基准值list[j]时，扫描终止
				i++;
			}
			if(i<j)
			{//扫描终止后，交换list[i]和list[j]的值，交换后list[i]中装的是基准值
				t=list[i];
				list[i]=list[j];
				list[j]=t;
			}
	   }//如此，i逐渐增加，j逐渐减小，最终i==j或j=i+1，此时即可得出中间值的位置，为i
	
	   list[i]=pivot;//为中间值的位置装上中间值，此位置的值就确定了。
	   //printf("%d\r%d\n",list[i],i);
	  
	   for(k=0;k<10;k++){
			printf("%d\t",list[k]);
		}
		printf("\n");
	   return i;//返回此位置的索引，方便后面确定左右区间的索引值。
	
	}


### 2.冒泡法

	# include<stdio.h>

	void bubble(int *list,int len)
	{
		int i,j,t;
		for(i=0;i<len-1;i++)
		{
			for(j=0;j<len-1-i;j++)
			{
				if(list[j]>list[j+1])
				{
					t=list[j];
					list[j]=list[j+1];
					list[j+1]=t;
				}			
			}
		}
	
	}
	
	void main()
	{
		int n,list[10];
		printf("请输入10个整数：");
		for(n=0;n<10;n++)
		{
			scanf("%d",&list[n]);
		}
		printf("\n");
		bubble(list,10);
		for(n=0;n<10;n++)
		{
			printf("%d\t",list[n]);
		}
		printf("\n");
		while(1)
		{
			;
		}
	
	
	}

## 3.插入法

	# include<stdio.h>

	void insertion(int *list,int len)
	{
		int i,t,n,j;
		for(i=0;i<len-1;i++)//以第一项为基础，每次循环把下一项插入到合适的位置
		{
			if(list[i+1]<list[i])//如果下一项比已排好的最后一项小（排好的已经是从小到大的顺序了），则把下一项的值保存为t,并把排好的最后一项赋值给下一项
			{
				t=list[i+1];
				list[i+1]=list[i];
				n=i;
				while(t<list[n-1])//从右向左将t与每一项比较，若t还比比较项小，则比较项右移一位，t继续与左边的项比较
				{
					
					list[n]=list[n-1];
					n--;
				}
				list[n]=t;//直到比较到t大于等于某一项（此时该项为list[n-1]），则把t插入该项的后面
			}
			for(j=0;j<len;j++)
			{
				printf("%d\t",list[j]);
			}
			printf("\n");
		}
	}
	
	void main()
	{
		int n,list[10];
		printf("请输入10个整数：");
		for(n=0;n<10;n++)
		{
			scanf("%d",&list[n]);
		}
		printf("\n");
		insertion(list,10);
		for(n=0;n<10;n++)
		{
			printf("%d\t",list[n]);
		}
		printf("\n");
		while(1)
		{
			;
		}
	
	
	}

## 4.shell排序（分组的插入排序）

	# include<stdio.h>
	void shell(int *list,int len,int d)//每轮都按照增量d进行插入排序
	{
		int i,t,n,j;
		for(i=0;i<len-d;i=i+d)
		{
			if(list[i+d]<list[i])
			{
				t=list[i+d];
				list[i+d]=list[i];
				n=i;
				while(t<list[n-d])
				{
					list[n]=list[n-d];
					n=n-d;
				}
				list[n]=t;
			}
		}
		for(j=0;j<len;j++)
		{
			printf("%d\t",list[j]);
		}
		printf("\n");
	
	}
	void shellSort(int *list,int len)
	{
		int increment=len;
		do
		{
			increment=increment/3+1;//设置初始增量为(长度/3+1)，以后每轮循环的增量都为(上一增量/3-1),直到增量为1
			shell(list,len,increment);
		}
		while(increment>1);
	}
	void main()
	{
		int n,list[10];
		printf("请输入10个整数：");
		for(n=0;n<10;n++)
		{
			scanf("%d",&list[n]);
		}
		printf("\n");
		shellSort(list,10);
		for(n=0;n<10;n++)
		{
			printf("%d\t",list[n]);
		}
		printf("\n");
		while(1)
		{
			;
		}
	
	
	}