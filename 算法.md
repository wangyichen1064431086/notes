# 算法复习
## 排序


### 1.交换法

#### （1）普通冒泡
- 时间复杂度：O(n^2)
- 空间复杂度：O(1)


		# include<stdio.h>
	
		void bubble(int *list,int len)
		{
			int i,j,t,flag=0;
			for(i=0;i<len-1;i++)
			{
				flag=0;//设置标记，当某一轮交换没有交换任何数，那下一轮交换也不必进行了
				for(j=0;j<len-1-i;j++)
				{
					if(list[j]>list[j+1])
					{
						t=list[j];
						list[j]=list[j+1];
						list[j+1]=t;
						flag=1;
					}			
				}
				if(flag==0)
				{
					break;
				}
			}
		
		}
		
		void main()
		{
			int n,list[10];
			printf("请输入10个整数：");
			for(n=0;n<10;n++)
			{
				scanf("%d",&list[n]);
			}
			printf("\n");
			bubble(list,10);
			for(n=0;n<10;n++)
			{
				printf("%d\t",list[n]);
			}
			printf("\n");
			while(1)
			{
				;
			}
		
		
		}

#### （2）鸡尾酒排序：双向冒泡
- 时间复杂度：O(n^2)
- 空间复杂度：O(1)
- 
	#include<stdio.h>

	void CocktailBubble(int *list,int n)
	{
		int low=0,high=n-1,j,t,flag;
		while(low<high)
		{
			flag=0;//一次进行两趟for循环，第一个for循环排最大值（次大值），第二个for循环排最小值（次小值），只要其中一趟没有交换任何数字就可以结束排序
			for(j=low;j<high;j++)
			{
				if(list[j]>list[j+1])
				{
					t=list[j];
					list[j]=list[j+1];
					list[j+1]=t;
					flag=1;
				}
			}
			if(flag==0)
			{
				break;
			}
			high--;//上述for循环第一次结束，排完最大值；第二次，排完次大值
			for(j=high;j>low;j--)
			{
				if(list[j]<list[j-1])
				{
					t=list[j];
					list[j]=list[j-1];
					list[j-1]=t;
				}
			}
			if(flag==0)
			{
				break;
			}
			low++;//上述for循环第一次结束，排完最小值；第二次，排完次小值
			
		}
	}
	
	void main(){
		int i,list[10];
		printf("请输入10个整数:");
		for(i=0;i<10;i++){
			scanf("%d",&list[i]);
		}
		for(i=0;i<10;i++){
			printf("%d ",list[i]);
		}
		printf("\n");
		CocktailBubble(list,10);
		for(i=0;i<10;i++){
			printf("%d ",list[i]);
		}
		printf("\n");
	
		while(1){
			;
		}
	}

#### （3）快速排序法
- 时间复杂度：平均O(nlog2n),最坏O(n2)
- 空间复杂度:O(log2n)


	# include<stdio.h>

	void quickSort(int *list,int i,int j);
	int Partition(int *list,int i,int j);
	
	main(){
		int list[10];
		int k;
		int i=0,j=9;
		printf("请输入10个数：");
		for(k=0;k<10;k++){
			scanf("%d",&list[k]);
		}
		printf("\n");
		quickSort(list,i,j);
		for(k=0;k<10;k++){
			printf("%d\t",list[k]);
		}
		printf("\n");
		while(1)
		{
			;	
		}
	}
	
	void quickSort(int *list,int i,int j){
		int pivotPos=0;//初始基准的位置选为0
		if(i<j){
			pivotPos=Partition(list,i,j);//调用Partition函数后，得到此基准值的位置（保证左边的小于它，右边的大于它）
			quickSort(list,i,pivotPos-1);//对基准值位置的左区间递归调用quickSort函数
			quickSort(list,pivotPos+1,j);//对基准值位置的右区间递归调用quickSort函数
		}
	
	}
	
	int Partition(int *list,int i,int j)
	{
	   
	   int pivot=list[i];//基准值首先设为list[i](i初始为0,故基准值即为list[0])
	   int t;
	   int k;
	  // printf("%d\r%d\n",i,j);
	   while(i<j)
	   {//当i<j时，轮流从右向左、从左向右遍历数组值与基准值比较
		   while(i<j&&list[j]>list[i])
		   {//当i<j时，从j向左扫描（即j--),当list[j]不再大于基准值list[j]时，扫描终止
				j--;
		   }
		   if(i<j)
		   {//扫描终止后，交换list[i]和list[j]的值，交换后list[j]中装的是基准值
		   		t=list[i];
				list[i]=list[j];
				list[j]=t;
		   }
		
	
			while(i<j&&list[i]<list[j])
			{//当i<j时，从i向右扫描（即i++)，当list[i]不再小于基准值list[j]时，扫描终止
				i++;
			}
			if(i<j)
			{//扫描终止后，交换list[i]和list[j]的值，交换后list[i]中装的是基准值
				t=list[i];
				list[i]=list[j];
				list[j]=t;
			}
	   }//如此，i逐渐增加，j逐渐减小，最终i==j或j=i+1，此时即可得出中间值的位置，为i
	
	   list[i]=pivot;//为中间值的位置装上中间值，此位置的值就确定了。
	   //printf("%d\r%d\n",list[i],i);
	  
	   for(k=0;k<10;k++){
			printf("%d\t",list[k]);
		}
		printf("\n");
	   return i;//返回此位置的索引，方便后面确定左右区间的索引值。
	
	}

第二次复习写的代码：

	#include<stdio.h>
	int Partition(int *list,int i,int j)
	{
		int t=list[i];
		while(i<j)
		{
			while(i<j&&list[j]>=t)
			{
				j--;
			}
			if(i<j)
			{
				list[i]=list[j];
				i++;
			}
			while(i<j&&list[i]<=t)
			{
				i++;
			}
			if(i<j)
			{
				list[j]=list[i];
				j--;
			}
		}
		list[i]=t;
		return i;
	}
	void QuikSort(int *list,int small,int big)
	{
		int p=0;
		if(small<big)
		{
			p=Partition(list,small,big);//排好P位置处的值，返回P
			QuikSort(list,small,p-1);
			QuikSort(list,p+1,big);
		}
	}
	
	
	
	void main(){
		int i,list[10];
		printf("请输入10个整数:");
		for(i=0;i<10;i++){
			scanf("%d",&list[i]);
		}
		for(i=0;i<10;i++){
			printf("%d ",list[i]);
		}
		printf("\n");
		QuikSort(list,0,9);
		for(i=0;i<10;i++){
			printf("%d ",list[i]);
		}
		printf("\n");
	
		while(1){
			;
		}
	}


### 3.插入法

#### (1)普通插入法
	# include<stdio.h>

	void insertion(int *list,int len)
	{
		int i,t,n,j;
		for(i=0;i<len-1;i++)//以第一项为基础，每次循环把下一项插入到合适的位置
		{
			if(list[i+1]<list[i])//如果下一项比已排好的最后一项小（排好的已经是从小到大的顺序了），则把下一项的值保存为t,并把排好的最后一项赋值给下一项
			{
				t=list[i+1];
				list[i+1]=list[i];
				n=i;
				while(t<list[n-1])//从右向左将t与每一项比较，若t还比比较项小，则比较项右移一位，t继续与左边的项比较
				{
					
					list[n]=list[n-1];
					n--;
				}
				list[n]=t;//直到比较到t大于等于某一项（此时该项为list[n-1]），则把t插入该项的后面
			}
			for(j=0;j<len;j++)
			{
				printf("%d\t",list[j]);
			}
			printf("\n");
		}
	}
	
	void main()
	{
		int n,list[10];
		printf("请输入10个整数：");
		for(n=0;n<10;n++)
		{
			scanf("%d",&list[n]);
		}
		printf("\n");
		insertion(list,10);
		for(n=0;n<10;n++)
		{
			printf("%d\t",list[n]);
		}
		printf("\n");
		while(1)
		{
			;
		}
	
	
	}

#### （2）shell排序：分组的插入排序

	# include<stdio.h>
	void shell(int *list,int len,int d)//每轮都按照增量d进行插入排序
	{
		int i,t,n,j;
		for(i=0;i<len-d;i=i+d)
		{
			if(list[i+d]<list[i])
			{
				t=list[i+d];
				list[i+d]=list[i];
				n=i;
				while(t<list[n-d])
				{
					list[n]=list[n-d];
					n=n-d;
				}
				list[n]=t;
			}
		}
		for(j=0;j<len;j++)
		{
			printf("%d\t",list[j]);
		}
		printf("\n");
	
	}
	void shellSort(int *list,int len)
	{
		int increment=len;
		do
		{
			increment=increment/3+1;//设置初始增量为(长度/3+1)，以后每轮循环的增量都为(上一增量/3-1),直到增量为1
			shell(list,len,increment);
		}
		while(increment>1);
	}
	void main()
	{
		int n,list[10];
		printf("请输入10个整数：");
		for(n=0;n<10;n++)
		{
			scanf("%d",&list[n]);
		}
		printf("\n");
		shellSort(list,10);
		for(n=0;n<10;n++)
		{
			printf("%d\t",list[n]);
		}
		printf("\n");
		while(1)
		{
			;
		}
	
	
	}

### 4.选择排序
#### （1）普通选择排序
	# include<stdio.h>
	
	int selectMinIndex(int *list,int len,int i)
	{
		int k=i,j;//k来记录最小项索引,k初始化为i。若后面某项list[j]小于list[i],则最小项索引k更新为j
		for(j=i+1;j<len;j++)
		{
			if(list[j]<list[i])
			{
				k=j;
			}
		}
		return k;
	}
	
	void selectSort(int *list,int len)//参数为数组，数组长度
	{
		int minIndex,i,t,n;
		for(i=0;i<len-1;i++)
		{
			minIndex=selectMinIndex(list,len,i);//循环执行len-1次，每次都选出list[i]~list[len-1]中值最小的一项的索引
			if(minIndex!=i)//最小项的索引若不为该次比较项（list[i]~list[len-1]）的第一项i,则交换最小项与第一项的值，将最小项装入list[i]
			{
				t=list[i];
				list[i]=list[minIndex];
				list[minIndex]=t;
			}
			for(n=0;n<10;n++)//输出每次比较的结果
			{
				printf("%d\t",list[n]);
			}
			printf("\n");
	
		}
	}
	
	
	void main()
	{
		int n,list[10];
		printf("请输入10个整数：");
		for(n=0;n<10;n++)
		{
			scanf("%d",&list[n]);
		}
		printf("\n");
		selectSort(list,10);
		for(n=0;n<10;n++)
		{
			printf("%d\t",list[n]);
		}
		printf("\n");
		while(1)
		{
			;
		}
	
	
	}

#### （2）二元选择排序

	# include<stdio.h>

	int selectMinIndex(int *list,int len,int i)
	{
		int k=i,j;//k来记录最小项索引,k初始化为i。若后面某项list[j]小于list[i],则最小项索引k更新为j
		for(j=i+1;j<len;j++)
		{
			if(list[j]<list[i])
			{
				k=j;
			}
		}
		return k;
	}
	
	int selectMaxIndex(int *list,int len,int i)
	{
		int k=len-1,j;//k来记录最大项索引,k初始化为len。若后面某项list[j]大于list[i],则最小项索引k更新为j
		for(j=len-2;j>i-1;j--)//与(j=i;j<len-1;j++)等价
		{
			if(list[j]>list[len-1])
			{
				k=j;
			}
		}
		return k;
	}
	
	void selectSort(int *list,int len)//参数为数组，数组长度
	{
		int minIndex,maxIndex,i,t,n;
		for(i=0;i<len/2;i++)
		{
			minIndex=selectMinIndex(list,len,i);//循环执行len-1次，每次都选出list[i]~list[len-1]中值最小的一项的索引
			if(minIndex!=i)//最小项的索引若不为该次比较项（list[i]~list[len-1]）的第一项i,则交换最小项与第一项的值，将最小项装入list[i]
			{
				t=list[i];
				list[i]=list[minIndex];
				list[minIndex]=t;
			}
			maxIndex=selectMaxIndex(list,len,i);
			if(maxIndex!=(len-1))
			{
				t=list[len-1];
				list[len-1]=list[maxIndex];
				list[maxIndex]=t;
			}
			for(n=0;n<10;n++)//输出每次比较的结果
			{
				printf("%d\t",list[n]);
			}
			printf("\n");
	
		}
	}
	
	
	
	
	
	void main()
	{
		int n,list[10];
		printf("请输入10个整数：");
		for(n=0;n<10;n++)
		{
			scanf("%d",&list[n]);
		}
		printf("\n");
		selectSort(list,10);
		for(n=0;n<10;n++)
		{
			printf("%d\t",list[n]);
		}
		printf("\n");
		while(1)
		{
			;
		}
	
	
	}